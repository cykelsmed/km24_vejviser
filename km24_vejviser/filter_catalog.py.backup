"""
Filter Catalog - Intelligent håndtering af KM24 filter-data

Denne modul håndterer dynamisk hentning og caching af alle filter-typer
fra KM24 API'et, samt intelligent matching mellem emner og relevante filtre.
"""

import logging
import json
import re
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass
from datetime import datetime, timedelta
import asyncio
from pathlib import Path

from .km24_client import get_km24_client, KM24APIClient
from .knowledge_base import extract_terms_from_text, map_terms_to_parts

logger = logging.getLogger(__name__)

@dataclass
class FilterRecommendation:
    """En anbefaling af et specifikt filter baseret på relevans."""
    filter_type: str
    values: List[str]
    relevance_score: float
    reasoning: str
    module_id: Optional[int] = None
    module_part_id: Optional[int] = None
    part_name: Optional[str] = None

@dataclass
class Municipality:
    """Repræsentation af en dansk kommune."""
    id: int
    name: str
    region: str
    population: Optional[int] = None
    area_km2: Optional[float] = None

@dataclass
class BranchCode:
    """Repræsentation af en branchekode."""
    code: str
    description: str
    category: str
    level: int  # 1-5 (hvor 1 er mest generel)

class FilterCatalog:
    """Intelligent katalog over alle KM24 filtre med caching og relevans-scoring."""
    
    def __init__(self):
        self.client: KM24APIClient = get_km24_client()
        
        # Cache for filter-data
        self._municipalities: Dict[int, Municipality] = {}
        self._branch_codes: Dict[str, BranchCode] = {}
        self._generic_values: Dict[int, List[Dict[str, Any]]] = {}
        self._web_sources: Dict[int, List[Dict[str, Any]]] = {}
        self._regions: Dict[int, Dict[str, Any]] = {}
        self._court_districts: Dict[int, Dict[str, Any]] = {}
        # Map from module title/id to parts and helpful reverse lookups
        self._module_id_by_title: Dict[str, int] = {}
        self._parts_by_module_id: Dict[int, List[Dict[str, Any]]] = {}
        # Knowledge extracted from modules/basic longDescription
        self._module_knowledge_base: Dict[str, Dict[str, Any]] = {}
        
        # Cache timestamps
        self._cache_timestamps: Dict[str, datetime] = {}
        self._cache_duration = timedelta(hours=24)  # 24 timer cache
        
        # Relevans keywords
        self._relevans_keywords = {
            'byggeri': ['bygge', 'byggeri', 'construction', 'ejendom', 'bolig', 'hus', 'bygning'],
            'detailhandel': ['detail', 'retail', 'butik', 'shop', 'handel', 'salg'],
            'sundhed': ['sundhed', 'health', 'hospital', 'læge', 'medicin', 'sygdom'],
            'transport': ['transport', 'logistik', 'fragt', 'shipping', 'bil', 'tog'],
            'finans': ['bank', 'finans', 'penge', 'kredit', 'lån', 'investering'],
            'landbrug': ['landbrug', 'agriculture', 'bonde', 'mark', 'dyr', 'korn'],
            'energi': ['energi', 'energy', 'strøm', 'vind', 'sol', 'gas', 'olie'],
            'miljø': ['miljø', 'environment', 'klima', 'forurening', 'natur'],
            'uddannelse': ['skole', 'education', 'universitet', 'læring', 'undervisning'],
            'politik': ['politik', 'politisk', 'valg', 'parti', 'regering', 'folketing']
        }

        # Modul-specifik deep-intelligence handlers (inkrementel kvalitet)
        self.deep_intelligence_handlers = {
            "status": self._handle_status_filters,
            "retslister": self._handle_retslister_filters,
            "domme": self._handle_domme_filters,
            "tinglysning": self._handle_tinglysning_filters,
            "arbejdstilsyn": self._handle_arbejdstilsyn_filters,
            "registrering": self._handle_registrering_filters,
            "lokalpolitik": self._handle_lokalpolitik_filters,
            "foedevaresmiley": self._handle_foedevaresmiley_filters,
        }

        # Build internal knowledge base from cached modules/basic
        try:
            self._extract_knowledge_from_modules()
        except Exception as e:
            logger.warning(f"Kunne ikke opbygge intern videnbase fra modules/basic: {e}")
    
    async def load_all_filters(self, force_refresh: bool = False) -> Dict[str, Any]:
        """Hent alle filter-data fra KM24 API."""
        logger.info("Indlæser alle filter-data fra KM24 API")
        
        # Also pre-load modules basic to build id/title map for module-specific parts
        tasks = [
            self._load_municipalities(force_refresh),
            self._load_branch_codes(force_refresh),
            self._load_regions(force_refresh),
            self._load_court_districts(force_refresh),
            self._load_modules_basic(force_refresh)
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        success_count = sum(1 for r in results if not isinstance(r, Exception))
        logger.info(f"Indlæst {success_count}/{len(tasks)} filter-kategorier")
        
        return {
            "municipalities": len(self._municipalities),
            "branch_codes": len(self._branch_codes),
            "regions": len(self._regions),
            "court_districts": len(self._court_districts),
            "modules": len(self._module_id_by_title),
            "cache_age": self._get_cache_age()
        }

    def _extract_knowledge_from_modules(self) -> None:
        """Indlæs `_api_modules_basic.json` og udtræk modul-viden.

        Opbygger `self._module_knowledge_base` som et mapping fra modul-slug
        til en struktur med udtrukne nøgleord og part-relationer.
        """

        cache_path = Path(__file__).parent / "cache" / "_api_modules_basic.json"
        if not cache_path.exists():
            logger.info("Ingen lokal modules/basic cache fundet – skipper videnudtræk")
            return

        try:
            with open(cache_path, "r", encoding="utf-8") as f:
                cached = json.load(f)
            # Cache format fra klienten: {'cached_at': ..., 'data': {...}}
            data = cached.get("data") if isinstance(cached, dict) and "data" in cached else cached
            items = data.get("items", []) if isinstance(data, dict) else []
        except Exception as e:
            logger.warning(f"Kunne ikke læse modules/basic cache: {e}")
            return

        knowledge: Dict[str, Dict[str, Any]] = {}

        for item in items:
            try:
                module_id = int(item.get("id")) if item.get("id") is not None else None
            except Exception:
                module_id = None
            slug = str(item.get("slug", "")).strip()
            title = str(item.get("title", "")).strip()
            long_description = str(item.get("longDescription", ""))
            parts = item.get("parts", []) or []

            if not slug:
                # Fald tilbage til titel som nøgle hvis slug mangler
                slug = title.casefold().replace(" ", "-") if title else "module-unknown"

            terms = extract_terms_from_text(long_description)
            # Map til parts – vi gemmer part-id/type og foreslåede værdier
            mappings = map_terms_to_parts(terms, parts, module_id or -1)

            knowledge[slug] = {
                "module_id": module_id,
                "title": title,
                "terms": sorted(terms),
                "mappings": [
                    {
                        "term": m.term,
                        "part_id": m.part_id,
                        "part_name": m.part_name,
                        "part_type": m.part_type,
                        "suggested_values": m.suggested_values,
                        "confidence": m.confidence,
                        "evidence": m.evidence,
                    }
                    for m in mappings
                ],
            }

            # Også prime `_module_id_by_title` og `_parts_by_module_id` hvis muligt
            if module_id is not None:
                if title:
                    self._module_id_by_title[title] = module_id
                if parts:
                    self._parts_by_module_id[module_id] = parts

        self._module_knowledge_base = knowledge
        logger.info(f"Opbygget intern videnbase for {len(self._module_knowledge_base)} moduler")

    async def _load_modules_basic(self, force_refresh: bool = False) -> None:
        """Indlæs moduler (basic) og bygg opslags-tabeller for parts."""
        try:
            resp = await self.client.get_modules_basic(force_refresh)
            if resp.success and resp.data:
                items = resp.data.get('items', [])
                self._module_id_by_title = {item.get('title', ''): int(item.get('id')) for item in items if item.get('id') is not None}
                # Prime parts cache with whatever basic response includes
                for item in items:
                    mid = int(item.get('id')) if item.get('id') is not None else None
                    if mid is None:
                        continue
                    if 'parts' in item:
                        self._parts_by_module_id[mid] = item.get('parts', [])
        except Exception as e:
            logger.warning(f"Kunne ikke indlæse modules basic i filter catalog: {e}")
    
    async def _load_municipalities(self, force_refresh: bool = False) -> None:
        """Indlæs kommuner fra API."""
        if not force_refresh and self._is_cache_valid("municipalities"):
            return
        
        try:
            response = await self.client.get_municipalities(force_refresh)
            if response.success and response.data:
                self._municipalities.clear()
                for item in response.data.get('items', []):
                    municipality = Municipality(
                        id=item.get('id'),
                        name=item.get('name'),
                        region=item.get('region', 'Ukendt'),
                        population=item.get('population'),
                        area_km2=item.get('area_km2')
                    )
                    self._municipalities[municipality.id] = municipality
                
                self._cache_timestamps["municipalities"] = datetime.now()
                logger.info(f"Indlæst {len(self._municipalities)} kommuner")
            else:
                logger.warning(f"Kunne ikke indlæse kommuner: {response.error}")
                # Fallback til test-data
                self._load_test_municipalities()
        except Exception as e:
            logger.error(f"Fejl ved indlæsning af kommuner: {e}")
            # Fallback til test-data
            self._load_test_municipalities()
    
    def _load_test_municipalities(self) -> None:
        """Indlæs test-kommuner når API ikke er tilgængelig."""
        test_municipalities = [
            Municipality(1, "Aarhus", "midtjylland", 273000, 468.0),
            Municipality(2, "København", "hovedstaden", 602000, 86.4),
            Municipality(3, "Odense", "syddanmark", 175000, 304.3),
            Municipality(4, "Aalborg", "nordjylland", 119000, 137.7),
            Municipality(5, "Esbjerg", "syddanmark", 115000, 742.5),
            Municipality(6, "Randers", "midtjylland", 62500, 800.1),
            Municipality(7, "Kolding", "syddanmark", 57000, 605.8),
            Municipality(8, "Horsens", "midtjylland", 58000, 520.0),
            Municipality(9, "Vejle", "syddanmark", 55000, 1066.3),
            Municipality(10, "Herning", "midtjylland", 50000, 1321.1),
        ]
        
        self._municipalities.clear()
        for muni in test_municipalities:
            self._municipalities[muni.id] = muni
        
        self._cache_timestamps["municipalities"] = datetime.now()
        logger.info(f"Indlæst {len(self._municipalities)} test-kommuner")
    
    async def _load_branch_codes(self, force_refresh: bool = False) -> None:
        """Indlæs branchekoder fra API."""
        if not force_refresh and self._is_cache_valid("branch_codes"):
            return
        
        try:
            response = await self.client.get_branch_codes_detailed(force_refresh)
            if response.success and response.data:
                self._branch_codes.clear()
                for item in response.data.get('items', []):
                    branch_code = BranchCode(
                        code=item.get('code'),
                        description=item.get('description'),
                        category=item.get('category', 'Ukendt'),
                        level=item.get('level', 1)
                    )
                    self._branch_codes[branch_code.code] = branch_code
                
                self._cache_timestamps["branch_codes"] = datetime.now()
                logger.info(f"Indlæst {len(self._branch_codes)} branchekoder")
            else:
                logger.warning(f"Kunne ikke indlæse branchekoder: {response.error}")
                # Fallback til test-data
                self._load_test_branch_codes()
        except Exception as e:
            logger.error(f"Fejl ved indlæsning af branchekoder: {e}")
            # Fallback til test-data
            self._load_test_branch_codes()
    
    def _load_test_branch_codes(self) -> None:
        """Indlæs test-branchekoder når API ikke er tilgængelig."""
        test_branch_codes = [
            BranchCode("41.1", "Byggearbejde til boliger", "byggeri", 3),
            BranchCode("41.2", "Byggearbejde til erhvervsejendomme", "byggeri", 3),
            BranchCode("41.3", "Byggearbejde til veje og jernbaner", "byggeri", 3),
            BranchCode("42.1", "Anlægsarbejde til veje og jernbaner", "byggeri", 3),
            BranchCode("42.2", "Anlægsarbejde til forsyningsanlæg", "byggeri", 3),
            BranchCode("43.1", "Tagdækning", "byggeri", 4),
            BranchCode("43.2", "Murerarbejde", "byggeri", 4),
            BranchCode("43.3", "Installation af bygningsinstallationer", "byggeri", 4),
            BranchCode("68.2", "Udlejning og drift af ejendomme", "ejendom", 3),
            BranchCode("68.3", "Ejendomsadministration", "ejendom", 3),
            BranchCode("47.1", "Detailhandel med ikke-specialiseret handel", "detailhandel", 3),
            BranchCode("47.2", "Detailhandel med fødevarer", "detailhandel", 3),
            BranchCode("86.1", "Sundhedsydelser", "sundhed", 3),
            BranchCode("86.2", "Praktiserende lægers og tandlægers virksomhed", "sundhed", 3),
            BranchCode("49.1", "Jernbanetransport", "transport", 3),
            BranchCode("49.2", "Anden landtransport", "transport", 3),
            BranchCode("64.1", "Geldinstitut", "finans", 3),
            BranchCode("64.2", "Holdingvirksomhed", "finans", 3),
            BranchCode("01.1", "Dyrkning af enårige afgrøder", "landbrug", 3),
            BranchCode("01.2", "Dyrkning af flerårige afgrøder", "landbrug", 3),
        ]
        
        self._branch_codes.clear()
        for code in test_branch_codes:
            self._branch_codes[code.code] = code
        
        self._cache_timestamps["branch_codes"] = datetime.now()
        logger.info(f"Indlæst {len(self._branch_codes)} test-branchekoder")
    
    async def _load_regions(self, force_refresh: bool = False) -> None:
        """Indlæs regioner fra API."""
        if not force_refresh and self._is_cache_valid("regions"):
            return
        
        try:
            response = await self.client.get_regions(force_refresh)
            if response.success and response.data:
                self._regions.clear()
                for item in response.data.get('items', []):
                    self._regions[item.get('id')] = item
                
                self._cache_timestamps["regions"] = datetime.now()
                logger.info(f"Indlæst {len(self._regions)} regioner")
            else:
                logger.warning(f"Kunne ikke indlæse regioner: {response.error}")
                # Fallback til test-data
                self._load_test_regions()
        except Exception as e:
            logger.error(f"Fejl ved indlæsning af regioner: {e}")
            # Fallback til test-data
            self._load_test_regions()
    
    def _load_test_regions(self) -> None:
        """Indlæs test-regioner når API ikke er tilgængelig."""
        test_regions = {
            1: {"id": 1, "name": "hovedstaden", "description": "Region Hovedstaden"},
            2: {"id": 2, "name": "midtjylland", "description": "Region Midtjylland"},
            3: {"id": 3, "name": "syddanmark", "description": "Region Syddanmark"},
            4: {"id": 4, "name": "nordjylland", "description": "Region Nordjylland"},
            5: {"id": 5, "name": "sjælland", "description": "Region Sjælland"},
        }
        
        self._regions.clear()
        self._regions.update(test_regions)
        
        self._cache_timestamps["regions"] = datetime.now()
        logger.info(f"Indlæst {len(self._regions)} test-regioner")
    
    async def _load_court_districts(self, force_refresh: bool = False) -> None:
        """Indlæs retskredse fra API."""
        if not force_refresh and self._is_cache_valid("court_districts"):
            return
        
        try:
            response = await self.client.get_court_districts(force_refresh)
            if response.success and response.data:
                self._court_districts.clear()
                for item in response.data.get('items', []):
                    self._court_districts[item.get('id')] = item
                
                self._cache_timestamps["court_districts"] = datetime.now()
                logger.info(f"Indlæst {len(self._court_districts)} retskredse")
            else:
                logger.warning(f"Kunne ikke indlæse retskredse: {response.error}")
                # Fallback til test-data
                self._load_test_court_districts()
        except Exception as e:
            logger.error(f"Fejl ved indlæsning af retskredse: {e}")
            # Fallback til test-data
            self._load_test_court_districts()
    
    def _load_test_court_districts(self) -> None:
        """Indlæs test-retskredse når API ikke er tilgængelig."""
        test_court_districts = {
            1: {"id": 1, "name": "Københavns Byret", "region": "hovedstaden"},
            2: {"id": 2, "name": "Aarhus Byret", "region": "midtjylland"},
            3: {"id": 3, "name": "Odense Byret", "region": "syddanmark"},
            4: {"id": 4, "name": "Aalborg Byret", "region": "nordjylland"},
            5: {"id": 5, "name": "Esbjerg Byret", "region": "syddanmark"},
        }
        
        self._court_districts.clear()
        self._court_districts.update(test_court_districts)
        
        self._cache_timestamps["court_districts"] = datetime.now()
        logger.info(f"Indlæst {len(self._court_districts)} test-retskredse")
    
    async def load_module_specific_filters(self, module_id: int, force_refresh: bool = False) -> Dict[str, Any]:
        """Indlæs modulspecifikke filtre (generic_values og web_sources)."""
        logger.info(f"Indlæser modulspecifikke filtre for modul {module_id}")
        
        try:
            # Hent modul detaljer for at få parts
            module_response = await self.client.get_module_details(int(module_id), force_refresh)
            if not module_response.success:
                return {"error": f"Kunne ikke hente modul {module_id}"}
            
            module_data = module_response.data
            parts = module_data.get('parts', [])
            # Cache parts
            self._parts_by_module_id[int(module_id)] = parts
            
            tasks = []
            for part in parts:
                if part.get('part') == 'generic_value':
                    part_id = part.get('id')
                    tasks.append(self._load_generic_values(part_id, force_refresh))
                elif part.get('part') == 'web_source':
                    tasks.append(self._load_web_sources(module_id, force_refresh))
            
            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)
            
            return {
                "module_id": module_id,
                "parts_loaded": len(parts),
                "generic_values_loaded": len([p for p in parts if p.get('part') == 'generic_value']),
                "web_sources_loaded": len([p for p in parts if p.get('part') == 'web_source'])
            }
            
        except Exception as e:
            logger.error(f"Fejl ved indlæsning af modulspecifikke filtre: {e}")
            return {"error": str(e)}
    
    async def _load_generic_values(self, module_part_id: int, force_refresh: bool = False) -> None:
        """Indlæs generic_values for en specifik modulpart."""
        cache_key = f"generic_values_{module_part_id}"
        if not force_refresh and self._is_cache_valid(cache_key):
            return
        
        try:
            response = await self.client.get_generic_values(module_part_id, force_refresh)
            if response.success and response.data:
                self._generic_values[module_part_id] = response.data.get('items', [])
                self._cache_timestamps[cache_key] = datetime.now()
                logger.info(f"Indlæst {len(self._generic_values[module_part_id])} generic_values for part {module_part_id}")
            else:
                logger.warning(f"Kunne ikke indlæse generic_values for part {module_part_id}: {response.error}")
        except Exception as e:
            logger.error(f"Fejl ved indlæsning af generic_values: {e}")
    
    async def _load_web_sources(self, module_id: int, force_refresh: bool = False) -> None:
        """Indlæs web_sources for et specifikt modul."""
        cache_key = f"web_sources_{module_id}"
        if not force_refresh and self._is_cache_valid(cache_key):
            return
        
        try:
            response = await self.client.get_web_sources(module_id, force_refresh)
            if response.success and response.data:
                self._web_sources[module_id] = response.data.get('items', [])
                self._cache_timestamps[cache_key] = datetime.now()
                logger.info(f"Indlæst {len(self._web_sources[module_id])} web_sources for modul {module_id}")
            else:
                logger.warning(f"Kunne ikke indlæse web_sources for modul {module_id}: {response.error}")
        except Exception as e:
            logger.error(f"Fejl ved indlæsning af web_sources: {e}")
    
    def get_relevant_filters(self, goal: str, modules: List[str]) -> List[FilterRecommendation]:
        """Returner relevante filtre baseret på mål og moduler.

        Først forsøges modul-specifik "deep intelligence" for anførte moduler.
        Hvis ingen handler findes eller ingen resultater, bruges fallback-logikken.
        """
        recommendations: List[FilterRecommendation] = []
        goal_lower = goal.lower()

        # 0) Modul-specifik dyb intelligens for eksplicit angivne moduler
        if modules:
            for mod in modules:
                key = (mod or "").strip().lower()
                handler = self.deep_intelligence_handlers.get(key)
                if handler:
                    try:
                        # Kør async handler i sync kontekst via event loop
                        deep_recs = asyncio.get_event_loop().run_until_complete(handler(goal))  # type: ignore
                        if deep_recs:
                            recommendations.extend(deep_recs)
                    except Exception as e:
                        logger.warning(f"Deep intelligence handler fejlede for {mod}: {e}")
        
        # 1) Klassiske heuristikker (kommuner/brancher/regioner)
        recommendations.extend(self._get_relevant_municipalities(goal_lower))
        recommendations.extend(self._get_relevant_branch_codes(goal_lower))
        recommendations.extend(self._get_relevant_regions(goal_lower))

        # 2) Hyper-relevant viden fra modules/basic longDescription
        try:
            # Uddrag termer fra målet (samme heuristik som knowledge_base)
            goal_terms = set(extract_terms_from_text(goal))

            # Begrænsning til valgte moduler (hvis angivet)
            selected_titles_lower = {m.lower() for m in modules} if modules else None

            for slug, entry in self._module_knowledge_base.items():
                title = (entry.get("title") or "").strip()
                if selected_titles_lower is not None and title.lower() not in selected_titles_lower:
                    continue

                module_id = entry.get("module_id")
                mappings = entry.get("mappings", [])
                for m in mappings:
                    term = m.get("term")
                    if term and term in goal_terms:
                        values = [v.capitalize() if isinstance(v, str) else v for v in m.get("suggested_values", []) or [term]]
                        part_name = m.get("part_name")
                        # FilterRecommendation expects a filter_type; vi bruger part-navn hvis kendt
                        filter_type = part_name if part_name else "module_specific"
                        # Saml anbefaling
                        recommendations.append(
                            FilterRecommendation(
                                filter_type=filter_type,
                                values=values,
                                relevance_score=0.95,
                                reasoning=f"Match mellem mål-termen '{term}' og {title} ({filter_type})",
                                module_id=module_id,
                                module_part_id=m.get("part_id"),
                                part_name=part_name,
                            )
                        )

            # 3) Konkrete lokale medie-forslag for udvalgte kommuner (heuristik)
            local_media = self._suggest_local_media(goal_lower)
            if local_media:
                recommendations.append(
                    FilterRecommendation(
                        filter_type="web_source",
                        values=local_media,
                        relevance_score=0.92,
                        reasoning="Lokale medier identificeret via geografiske nøgleord i målet",
                    )
                )

            # 4) Fallback: Kendte stærke modulspecifikke termer uden longDescription-match
            # Hvis 'asbest' nævnes, foreslå Problem: Asbest for Arbejdstilsyn
            if "asbest" in goal_terms:
                # Undgå dubletter hvis allerede foreslået
                already_has_asbest = any(
                    any((isinstance(v, str) and v.lower() == "asbest") for v in r.values)
                    for r in recommendations
                )
                if not already_has_asbest:
                    filter_type = "Problem"
                    module_id = self._get_module_id("Arbejdstilsyn")
                    recommendations.append(
                        FilterRecommendation(
                            filter_type=filter_type,
                            values=["Asbest"],
                            relevance_score=0.94,
                            reasoning="Mål nævner asbest → foreslå Problem: Asbest (Arbejdstilsyn)",
                            module_id=module_id,
                            part_name="Problem",
                        )
                    )

            # 5) Målrettet indhentning af specifikke værdier flyttet til async metode

        except Exception as e:
            logger.warning(f"Fejl i hyper-relevant videnudtræk: {e}")
        
        return sorted(recommendations, key=lambda x: x.relevance_score, reverse=True)

    async def get_relevant_filters_with_values(self, goal: str, modules: List[str]) -> List[FilterRecommendation]:
        """Udvidede anbefalinger med dynamisk indhentede, konkrete værdier for relevante parts.

        Starter med basisanbefalinger og supplerer med semantisk udvalgte `generic_values`
        fra KM24 API for de moduler der er angivet i `modules`.
        """
        base_recs = self.get_relevant_filters(goal, modules)
        goal_lower = (goal or "").lower()

        if not modules:
            return base_recs

        augmented: List[FilterRecommendation] = list(base_recs)
        for module_name in modules:
            module_id = self._get_module_id(module_name)
            if not module_id:
                continue
            try:
                await self.load_module_specific_filters(module_id)
            except Exception:
                pass
            parts = self._parts_by_module_id.get(module_id, [])
            for part in parts:
                if part.get('part') != 'generic_value':
                    continue
                pid = part.get('id')
                pname = part.get('name') or ''
                values = self._generic_values.get(pid, [])
                if not values:
                    try:
                        await self._load_generic_values(pid)
                        values = self._generic_values.get(pid, [])
                    except Exception:
                        values = []
                if not values:
                    continue
                scored: List[Tuple[float, str]] = []
                for it in values:
                    name = str(it.get('name', '')).strip()
                    desc = str(it.get('description', '') or '')
                    score = self._semantic_match_score(goal_lower, f"{name} {desc}")
                    if score > 0:
                        scored.append((score, name))
                if not scored:
                    continue
                scored.sort(key=lambda x: x[0], reverse=True)
                top_values = [n for _, n in scored[:5]]
                filter_type = self._normalized_filter_type_from_part_name(pname) or (pname or "module_specific").strip().lower()
                augmented.append(
                    FilterRecommendation(
                        filter_type=filter_type,
                        values=top_values,
                        relevance_score=0.96,
                        reasoning=f"Semantisk match mellem mål og {pname} i {module_name}",
                        module_id=module_id,
                        module_part_id=pid,
                        part_name=pname,
                    )
                )

        return sorted(augmented, key=lambda x: x.relevance_score, reverse=True)

    async def get_hyper_relevant_filters(self, goal: str) -> List[FilterRecommendation]:
        """Hent hyper-relevante, API-validerede værdier for semantisk relevante parts.

        - Identificerer parts af typen generic_value på tværs af moduler
        - Begrænser til kendte, nyttige kategorier (crime_codes/problem/reaction/branch/property)
        - Henter konkrete værdier via API og scorer dem mod målet
        - Returnerer top 3-5 faktisk gyldige værdier per part
        """
        goal_lower = (goal or "").lower()
        results: List[FilterRecommendation] = []

        # Scan et begrænset sæt moduler for performance
        module_items = list(self._module_id_by_title.items())
        # Prioritér moduler hvis titel matcher nogle domæneord
        priority_terms = ['dom', 'ret', 'arbejdstilsyn', 'miljø', 'tinglys', 'udbud', 'status', 'registr']
        prioritized = [
            (title, mid) for title, mid in module_items
            if any(t in title.lower() for t in priority_terms)
        ] + module_items

        seen_modules: Set[int] = set()
        for title, module_id in prioritized:
            if module_id in seen_modules:
                continue
            seen_modules.add(module_id)
            try:
                await self.load_module_specific_filters(module_id)
            except Exception:
                pass
            parts = self._parts_by_module_id.get(module_id, [])
            for part in parts:
                if part.get('part') != 'generic_value':
                    continue
                pname = part.get('name') or ''
                normalized = self._normalized_filter_type_from_part_name(pname)
                if normalized not in {"crime_codes", "problem", "reaction", "branch_codes", "property_types"}:
                    continue
                pid = part.get('id')
                values = self._generic_values.get(pid, [])
                if not values:
                    try:
                        await self._load_generic_values(pid)
                        values = self._generic_values.get(pid, [])
                    except Exception:
                        values = []
                if not values:
                    continue
                # Score values mod mål
                scored: List[Tuple[float, str]] = []
                for it in values:
                    name = str(it.get('name', '')).strip()
                    desc = str(it.get('description', '') or '')
                    score = self._semantic_match_score(goal_lower, f"{name} {desc}")
                    if score > 0:
                        scored.append((score, name))
                if not scored:
                    continue
                scored.sort(key=lambda x: x[0], reverse=True)
                top_values = [n for _, n in scored[:5]]
                results.append(
                    FilterRecommendation(
                        filter_type=normalized or (pname or "module_specific").strip().lower(),
                        values=top_values,
                        relevance_score=0.97,
                        reasoning=f"API-validerede {pname} for {title}",
                        module_id=module_id,
                        module_part_id=pid,
                        part_name=pname,
                    )
                )

            # Stop tidligt hvis vi allerede har samlet en del
            if len(results) >= 10:
                break

        return sorted(results, key=lambda x: x.relevance_score, reverse=True)

    def _suggest_local_media(self, goal_lower: str) -> List[str]:
        """Returnér konkrete lokale medier for udvalgte områder (heuristik)."""
        # Denne kan udvides gradvist; starter med 'Esbjerg'
        if "esbjerg" in goal_lower:
            return ["JydskeVestkysten", "Esbjerg Ugeavis"]
        return []
    
    def _get_relevant_municipalities(self, goal: str) -> List[FilterRecommendation]:
        """Find relevante kommuner baseret på mål."""
        recommendations = []
        
        # Keywords for forskellige regioner
        region_keywords = {
            'københavn': ['københavn', 'copenhagen', 'hovedstaden', 'storkøbenhavn'],
            'aarhus': ['aarhus', 'jylland', 'midtjylland', 'østjylland'],
            'odense': ['odense', 'fyn', 'sydfyn'],
            'aalborg': ['aalborg', 'nordjylland', 'nordjylland'],
            'vestjylland': ['vestjylland', 'esbjerg', 'herning', 'holstebro', 'struer'],
            'østjylland': ['østjylland', 'randers', 'horsens', 'vejle', 'kolding'],
            'sydjylland': ['sydjylland', 'sønderborg', 'aabenraa', 'tønder']
        }
        
        for region, keywords in region_keywords.items():
            if any(keyword in goal for keyword in keywords):
                # Find kommuner i denne region
                region_municipalities = [
                    m for m in self._municipalities.values() 
                    if region in m.region.lower() or any(keyword in m.name.lower() for keyword in keywords)
                ]
                
                if region_municipalities:
                    recommendations.append(FilterRecommendation(
                        filter_type="municipality",
                        values=[m.name for m in region_municipalities[:5]],  # Top 5
                        relevance_score=0.9,
                        reasoning=f"Relevante kommuner i {region}-regionen baseret på mål"
                    ))
        
        return recommendations
    
    def _get_relevant_branch_codes(self, goal: str) -> List[FilterRecommendation]:
        """Find relevante branchekoder baseret på mål."""
        recommendations = []
        
        for category, keywords in self._relevans_keywords.items():
            if any(keyword in goal for keyword in keywords):
                # Find branchekoder i denne kategori
                relevant_codes = [
                    bc for bc in self._branch_codes.values()
                    if any(keyword in bc.description.lower() for keyword in keywords)
                ]
                
                if relevant_codes:
                    # Gruppér efter kategori og vælg de mest relevante
                    codes_by_category = {}
                    for code in relevant_codes:
                        if code.category not in codes_by_category:
                            codes_by_category[code.category] = []
                        codes_by_category[code.category].append(code)
                    
                    for category_name, codes in codes_by_category.items():
                        # Vælg de mest specifikke koder (højeste level)
                        codes.sort(key=lambda x: x.level, reverse=True)
                        selected_codes = [c.code for c in codes[:3]]  # Top 3
                        
                        recommendations.append(FilterRecommendation(
                            filter_type="industry",
                            values=selected_codes,
                            relevance_score=0.85,
                            reasoning=f"Relevante branchekoder for {category_name} baseret på mål"
                        ))
        
        return recommendations
    
    def _get_relevant_regions(self, goal: str) -> List[FilterRecommendation]:
        """Find relevante regioner baseret på mål."""
        recommendations = []
        
        region_keywords = {
            'hovedstaden': ['københavn', 'hovedstaden', 'storkøbenhavn'],
            'midtjylland': ['aarhus', 'midtjylland', 'østjylland'],
            'syddanmark': ['fyn', 'sydfyn', 'odense', 'syddanmark'],
            'nordjylland': ['aalborg', 'nordjylland'],
            'sjælland': ['sjælland', 'roskilde', 'køge']
        }
        
        for region_name, keywords in region_keywords.items():
            if any(keyword in goal for keyword in keywords):
                recommendations.append(FilterRecommendation(
                    filter_type="region",
                    values=[region_name],
                    relevance_score=0.8,
                    reasoning=f"Relevant region baseret på geografiske keywords"
                ))
        
        return recommendations
    
    def _is_cache_valid(self, cache_key: str) -> bool:
        """Tjek om cache er gyldig."""
        if cache_key not in self._cache_timestamps:
            return False
        
        cache_age = datetime.now() - self._cache_timestamps[cache_key]
        return cache_age < self._cache_duration
    
    def _get_cache_age(self) -> Optional[str]:
        """Hent alder af ældste cache."""
        if not self._cache_timestamps:
            return None
        
        oldest_timestamp = min(self._cache_timestamps.values())
        age = datetime.now() - oldest_timestamp
        return str(age)
    
    def get_municipalities_by_region(self, region: str) -> List[Municipality]:
        """Hent kommuner i en specifik region."""
        return [m for m in self._municipalities.values() if region.lower() in m.region.lower()]
    
    def get_branch_codes_by_category(self, category: str) -> List[BranchCode]:
        """Hent branchekoder i en specifik kategori."""
        return [bc for bc in self._branch_codes.values() if category.lower() in bc.category.lower()]
    
    def get_generic_values_for_module_part(self, module_part_id: int) -> List[Dict[str, Any]]:
        """Hent generic_values for en specifik modulpart."""
        return self._generic_values.get(module_part_id, [])
    
    def get_web_sources_for_module(self, module_id: int) -> List[Dict[str, Any]]:
        """Hent web_sources for et specifikt modul."""
        return self._web_sources.get(module_id, [])

    async def get_module_specific_recommendations(self, goal: str, module_name: str) -> List[FilterRecommendation]:
        """Hent modulspecifikke filter-anbefalinger."""
        recommendations = []
        
        # Indlæs modulspecifikke filtre hvis nødvendigt
        module_id = self._get_module_id(module_name)
        if module_id:
            # Deep intelligence first if we have a handler
            key = (module_name or "").strip().lower()
            handler = self.deep_intelligence_handlers.get(key)
            if handler:
                try:
                    deep_recs = handler(goal)
                    if asyncio.iscoroutine(deep_recs):
                        deep_recs = await deep_recs  # type: ignore
                    if deep_recs:
                        recommendations.extend(deep_recs)
                except Exception as e:
                    logger.warning(f"Deep intelligence handler fejlede for {module_name}: {e}")
            await self.load_module_specific_filters(module_id)
            
            # Hent generic_values for modulet (med semantisk scoring)
            # Resolve all generic_value lists from cached module parts
            generic_parts = [p for p in self._parts_by_module_id.get(module_id, []) if p.get('part') == 'generic_value']
            generic_value_part_ids = [p.get('id') for p in generic_parts]
            goal_lower = (goal or "").lower()
            for part in generic_parts:
                pid = part.get('id')
                pname = part.get('name') or ''
                items = self._generic_values.get(pid, [])
                if not items:
                    continue
                # Semantisk scoring af hver værdi ud fra navn/beskrivelse
                scored: List[Tuple[float, str]] = []
                for it in items:
                    name = str(it.get('name', '')).strip()
                    desc = str(it.get('description', '') or '')
                    score = self._semantic_match_score(goal_lower, f"{name} {desc}")
                    if score > 0:
                        scored.append((score, name))
                # Hvis intet scorede positivt, vælg nogle repræsentative defaults (top N alfabetisk)
                selected: List[str] = []
                if scored:
                    scored.sort(key=lambda x: x[0], reverse=True)
                    selected = [n for _, n in scored[:5]]
                else:
                    selected = [str(it.get('name')) for it in items[:3] if it.get('name')]
                if selected:
                    filter_type = self._normalized_filter_type_from_part_name(pname)
                recommendations.append(FilterRecommendation(
                        filter_type=filter_type or "module_specific",
                        values=selected,
                        relevance_score=0.9 if scored else 0.7,
                        reasoning=f"Udvalgt fra {pname} for {module_name}",
                    module_id=module_id,
                        part_name=pname
                ))
            
            # Hent web_sources for modulet
            web_sources = self.get_web_sources_for_module(module_id)
            if web_sources:
                recommendations.append(FilterRecommendation(
                    filter_type="web_sources",
                    values=[source.get('name', '') for source in web_sources[:5]],  # Top 5 kilder
                    relevance_score=0.85,
                    reasoning=f"Webkilder for {module_name}",
                    module_id=module_id
                ))
        
        # Heuristics for specific modules when goal suggests severe violations
        g = goal.lower()
        if 'arbejdstilsyn' in module_name.lower() and any(k in g for k in ['alvorlig', 'alvorlige', 'overtrædelse', 'ulovlig', 'kritik']):
            recommendations.append(FilterRecommendation(
                filter_type="module_specific",
                values=["Forbud", "Strakspåbud"],
                relevance_score=0.95,
                reasoning="Ved alvorlige overtrædelser anbefales Reaktion: Forbud/Strakspåbud",
                part_name="Reaktion"
            ))
            if 'asbest' in g:
                recommendations.append(FilterRecommendation(
                    filter_type="module_specific",
                    values=["Asbest"],
                    relevance_score=0.92,
                    reasoning="Asbest relaterede sager: Problem = Asbest",
                    part_name="Problem"
                ))

        if 'tinglysning' in module_name.lower() and any(k in g for k in ['ejendom', 'ejendomshandel', 'handel']):
            recommendations.append(FilterRecommendation(
                filter_type="module_specific",
                values=["erhvervsejendom", "landbrugsejendom"],
                relevance_score=0.9,
                reasoning="Tinglysning: ejendomstyper via generic_value",
                part_name="Ejendomstype"
            ))

        return recommendations

    def _normalized_filter_type_from_part_name(self, part_name: Optional[str]) -> Optional[str]:
        if not part_name:
            return None
        n = part_name.lower()
        # Common normalizations across modules
        if 'gernings' in n or 'crime' in n:
            return 'crime_codes'
        if 'branche' in n or 'industry' in n:
            return 'branch_codes'
        if 'problem' in n:
            return 'problem'
        if 'reaktion' in n or 'reaction' in n:
            return 'reaction'
        if 'ejendom' in n or 'property' in n:
            return 'property_types'
        return None

    def _semantic_match_score(self, goal_lower: str, text: str) -> float:
        """Simpel semantisk scoring baseret på domæne-ordlister og substring-match."""
        if not goal_lower or not text:
            return 0.0
        t = text.lower()
        score = 0.0
        # Domain term buckets
        buckets = {
            'corruption': ['korruption', 'bestikkelse', 'bestikk', 'habilitet', 'inhabil', 'smørelse'],
            'fraud': ['bedrageri', 'svig', 'falsk', 'økonomisk kriminalitet'],
            'environment': ['miljø', 'forurening', 'udledning', 'tilladelse', 'asbest', 'klima'],
            'labour': ['arbejdstilsyn', 'forbud', 'strakspåbud', 'ulykke', 'sikkerhed'],
            'construction': ['bygge', 'byggeri', 'entrepren', 'udvikling', 'ejendom'],
            'procurement': ['udbud', 'kontrakt', 'tildeling', 'offentlig'],
            'media': ['medie', 'avis', 'ugeavis', 'nyhed']
        }
        for key, terms in buckets.items():
            bucket_hits = 0
            for term in terms:
                if term in goal_lower and term in t:
                    bucket_hits += 1
            if bucket_hits:
                # Weight by number of overlapping terms
                score += 0.4 + 0.2 * min(bucket_hits, 3)
        # Fallback: direct keyword overlap by tokens
        for token in set(goal_lower.split()):
            if len(token) > 4 and token in t:
                score += 0.1
        return score

    # ------------------ Deep Intelligence Handlers (8 core modules) ------------------

    async def _handle_status_filters(self, goal: str) -> List[FilterRecommendation]:
        """Håndterer dyb intelligens for Status-modulet med udvidet genkendelse."""
        logger.info("Attempting to run _handle_status_filters...")
        recommendations: List[FilterRecommendation] = []
        goal_lower = (goal or "").lower()

        # Udvidet intention_map for robust semantisk matchning
        intention_map: Dict[str, Dict[str, List[str]]] = {
            "lukning": {
                "keywords": [
                    "lukker", "lukning", "lukket", "konkurs", "ophør", "ophørt",
                    "tvangsopløst", "likvidation", "likvideret", "svingdørsselskaber",
                    "opløst", "afvikling", "afvikles", "under afvikling",
                    "konkurshistorik", "virksomhedslukninger", "butiksdød"
                ],
                "values": ["Ophørt", "Tvangsopløst", "Opløst efter konkurs", "Under konkurs", "Under tvangsopløsning"],
            },
            "opstart": {
                "keywords": ["starter", "aktiv", "normal", "nyregistreret", "etableret"],
                "values": ["Aktiv", "Normal"],
            },
            "problemer": {
                "keywords": [
                    "problemer", "risiko", "rekonstruktion", "under administration",
                    "social dumping", "økonomisk pres"
                ],
                "values": ["Under konkurs", "Under tvangsopløsning", "Under rekonstruktion"],
            },
        }

        for intent_name, data in intention_map.items():
            if any(keyword in goal_lower for keyword in data["keywords"]):
                logger.info(f"Status handler triggered. Found intent: '{intent_name}' in goal.")
                recommendations.append(
                    FilterRecommendation(
                        filter_type="statustype",
                        values=list(set(data["values"])),
                        relevance_score=0.98,
                        reasoning=f"Identificerede intention om '{intent_name}' i målet."
                    )
                )
                # Stop efter første match for at undgå overlappende forslag
                break

        if not recommendations:
            logger.warning("Status handler did NOT find a matching intent in the goal.")

        return recommendations

    async def _handle_retslister_filters(self, goal: str) -> List[FilterRecommendation]:
        """Retslister: match 'vold', 'drab', 'narko' mod gerningskoder og retsinstanser."""
        g = (goal or "").lower()
        terms = {
            "vold": ["Vold", "Grov vold"],
            "drab": ["Drab", "Forsøg på drab"],
            "nark": ["Narkotika", "Euforiserende stoffer"],
        }
        crime: List[str] = []
        for k, vals in terms.items():
            if k in g:
                crime.extend(vals)
        recs: List[FilterRecommendation] = []
        if crime:
            recs.append(FilterRecommendation(
                filter_type="crime_codes",
                values=sorted(list(set(crime))),
                relevance_score=0.92,
                reasoning="Retslister: match på gerningskoder"
            ))
        if any(x in g for x in ["byret", "landsret", "højesteret", "ret i"]):
            instances = [v for v in ["Byret", "Landsret", "Højesteret"] if v.lower() in g]
            if instances:
                recs.append(FilterRecommendation(
                    filter_type="retinstans",
                    values=instances,
                    relevance_score=0.8,
                    reasoning="Retsinstans nævnt i mål"
                ))
        return recs

    async def _handle_domme_filters(self, goal: str) -> List[FilterRecommendation]:
        """Domme: samme logik som retslister men reaktiv analyse."""
        recs = await self._handle_retslister_filters(goal)
        for r in recs:
            r.relevance_score = max(r.relevance_score - 0.02, 0.0)
            r.reasoning = "Domme: reaktiv analyse baseret på gerningskoder"
        return recs

    async def _handle_tinglysning_filters(self, goal: str) -> List[FilterRecommendation]:
        """Tinglysning: beløbsgrænser og ejendomstyper baseret på mål."""
        g = (goal or "").lower()
        recs: List[FilterRecommendation] = []
        # Beløbsgrænse heuristik
        if any(w in g for w in ["stor", "større", ">", "million", "mio", "10 mio", "100 mio"]):
            recs.append(FilterRecommendation(
                filter_type="beløbsgrænse",
                values=["10000000"],
                relevance_score=0.9,
                reasoning="Store handler: beløbsgrænse sat til >= 10 mio"
            ))
        # Ejendomstype
        types: List[str] = []
        if "landbrug" in g:
            types.append("landbrugsejendom")
        if "erhverv" in g or "erhvervsejendom" in g:
            types.append("erhvervsejendom")
        if types:
            recs.append(FilterRecommendation(
                filter_type="property_types",
                values=sorted(list(set(types))),
                relevance_score=0.88,
                reasoning="Ejendomstyper afledt af mål"
            ))
        return recs

    async def _handle_arbejdstilsyn_filters(self, goal: str) -> List[FilterRecommendation]:
        """Arbejdstilsyn: problem- og reaktionsværdier (kontekst-specifikke)."""
        g = (goal or "").lower()
        recs: List[FilterRecommendation] = []

        # Bevar reaktions-logik (alvorlige sager)
        if any(k in g for k in ["alvorlig", "overtrædelse", "kritik", "ulovlig", "ulykke", "grove"]):
            recs.append(FilterRecommendation(
                filter_type="reaction",
                values=["Forbud", "Strakspåbud"],
                relevance_score=0.95,
                reasoning="Alvorlige overtrædelser → Reaktion: Forbud/Strakspåbud"
            ))

        # Kontekst-specifikke Problem-værdier baseret på branche og mål
        industry_keywords: Dict[str, List[str]] = {
            "fødevareproduktion": ["fødevare", "slagteri", "slagter", "kød", "mejeri", "forarbejd", "produktion", "pakkeri"],
            "byggeri": ["bygge", "entrepren", "nedriv", "tag", "stillads", "beton", "anlæg"],
            "kontor": ["kontor", "administration", "skrivebord", "callcenter"],
            "transport": ["vognmand", "lastbil", "chauffør", "transport", "logistik"],
            "lager": ["lager", "terminal", "pluk", "truck"],
        }
        problem_map: Dict[str, List[str]] = {
            # Termene her er søgetermer der matcher API'ets problem-navne case-insensitive (delmatch)
            "fødevareproduktion": ["maskin", "tunge løft", "hygiejne", "kemikal", "ergonomi", "kniv", "skære"],
            "byggeri": ["asbest", "fald til lavere niveau", "støj", "støv", "nedstyrt", "kemi"],
            "kontor": ["stress", "psykisk", "ergonomi", "alenearbejde"],
            "transport": ["tunge løft", "ergonomi", "ulykke", "truck", "kemikal"],
            "lager": ["tunge løft", "ergonomi", "truck", "palleløfter", "ulykke"],
        }

        # Find relevante brancher i målet
        matched_industries: List[str] = []
        for industry, keys in industry_keywords.items():
            if any(k in g for k in keys):
                matched_industries.append(industry)

        selected_problem_terms: List[str] = []
        for industry in matched_industries:
            selected_problem_terms.extend(problem_map.get(industry, []))

        # Særtilfælde fra mål
        if "asbest" in g and "asbest" not in selected_problem_terms:
            selected_problem_terms.append("asbest")
        if any(k in g for k in ["stress", "psykisk"]) and "psykisk" not in selected_problem_terms:
            selected_problem_terms.append("psykisk")

        # Hent Problem-listen fra API for Arbejdstilsyn og match semantisk
        try:
            at_module_id = self._get_module_id("Arbejdstilsyn")
            if at_module_id:
                await self.load_module_specific_filters(at_module_id)
                problem_part_ids: List[int] = []
                for p in self._parts_by_module_id.get(at_module_id, []):
                    if p.get("part") == "generic_value" and str(p.get("name", "")).lower().strip().startswith("problem"):
                        pid = p.get("id")
                        if pid is not None:
                            problem_part_ids.append(pid)
                matched_values: List[str] = []
                for pid in problem_part_ids:
                    items = self._generic_values.get(pid, [])
                    for it in items:
                        name = str(it.get("name", ""))
                        nl = name.lower()
                        if selected_problem_terms:
                            if any(term in nl for term in selected_problem_terms):
                                matched_values.append(name)
                        else:
                            # Ingen brancher fundet – match brede risici hvis mål har nøgleord
                            if any(term in nl for term in ["asbest", "stress", "ulykke", "maskin", "ergonomi"]):
                                matched_values.append(name)
                if matched_values:
                    # Deduplicate og begræns
                    uniq = []
                    seen = set()
                    for v in matched_values:
                        if v not in seen:
                            seen.add(v)
                            uniq.append(v)
                    recs.append(FilterRecommendation(
                        filter_type="problem",
                        values=uniq[:5],
                        relevance_score=0.94,
                        reasoning="Kontekst-specifikke problemer matchet mod branche og mål",
                        part_name="Problem",
                        module_id=at_module_id
                    ))
        except Exception as e:
            logger.warning(f"Kontekstspecifik problem-matchning fejlede: {e}")

        # Bevar simple fallback hvis intet fundet og mål nævner nøgleord
        if not any(r.filter_type == "problem" for r in recs):
            if "asbest" in g:
                recs.append(FilterRecommendation(
                    filter_type="problem",
                    values=["Asbest"],
                    relevance_score=0.9,
                    reasoning="Fallback: Problem = Asbest"
                ))
            elif any(k in g for k in ["stress", "psykisk"]):
                recs.append(FilterRecommendation(
                    filter_type="problem",
                    values=["Psykisk arbejdsmiljø"],
                    relevance_score=0.82,
                    reasoning="Fallback: Problem = Psykisk arbejdsmiljø"
                ))

        return recs

    async def _handle_registrering_filters(self, goal: str) -> List[FilterRecommendation]:
        """Registrering: branchekode forslag baseret på brancher i mål."""
        g = (goal or "").lower()
        mapping = {
            "restaurant": ["56.10", "56.30"],
            "cafe": ["56.10"],
            "bygge": ["41.20", "43.11", "43.21", "43.29"],
            "detail": ["47.11", "47.19", "47.30"],
            "ejendom": ["68.20", "68.30"],
            "transport": ["49.41", "52.29"],
        }
        selected: List[str] = []
        for k, codes in mapping.items():
            if k in g:
                selected.extend(codes)
        if selected:
            return [FilterRecommendation(
                filter_type="branch_codes",
                values=sorted(list(set(selected)))[:5],
                relevance_score=0.9,
                reasoning="Brancher afledt af mål"
            )]
        return []

    async def _handle_lokalpolitik_filters(self, goal: str) -> List[FilterRecommendation]:
        """Lokalpolitik: dokumenttyper/søgeord for bygge/miljø/sociale forhold."""
        g = (goal or "").lower()
        recs: List[FilterRecommendation] = []
        if any(k in g for k in ["bygge", "byggesag", "lokalplan"]):
            recs.append(FilterRecommendation(
                filter_type="dokumenttype",
                values=["Lokalplan", "Byggesag"],
                relevance_score=0.82,
                reasoning="Bygge-relaterede beslutninger"
            ))
        if any(k in g for k in ["miljø", "forurening", "udledning"]):
            recs.append(FilterRecommendation(
                filter_type="dokumenttype",
                values=["Miljøtilladelse", "Høring"],
                relevance_score=0.8,
                reasoning="Miljø-relaterede beslutninger"
            ))
        if any(k in g for k in ["social", "borgere", "skole", "daginstitution"]):
            recs.append(FilterRecommendation(
                filter_type="søgeord",
                values=["indsats", "tilsyn", "budget"],
                relevance_score=0.75,
                reasoning="Sociale forhold nøgleord"
            ))
        return recs

    async def _handle_foedevaresmiley_filters(self, goal: str) -> List[FilterRecommendation]:
        """FødevareSmiley: niveau til de sureste smileys/opfølgning."""
        g = (goal or "").lower()
        if any(k in g for k in ["sur", "dårlig", "kritik", "hygiejne"]):
            return [FilterRecommendation(
                filter_type="niveau",
                values=["Indskærpelse", "Påbud", "Sanktion"],
                relevance_score=0.85,
                reasoning="Sure smileys / dårlig hygiejne"
            )]
        return []
    
    def _get_module_id(self, module_name: str) -> Optional[int]:
        """Hent modul ID baseret på modulnavn."""
        if self._module_id_by_title:
            # Direct title match first
            mid = self._module_id_by_title.get(module_name)
            if mid is not None:
                return mid
            # Try a case-insensitive match
            for title, mid in self._module_id_by_title.items():
                if title.lower() == module_name.lower():
                    return mid
        return None
    
    def get_generic_values_for_module(self, module_name: str) -> List[str]:
        """Deprecated: Brug get_module_specific_recommendations i stedet."""
        return []
    
    async def get_module_filter_metadata(self, module_title: str) -> Dict[str, Any]:
        """
        Hent komplet filter-metadata for et modul.
        
        Returns:
            {
                "module_id": 280,
                "module_title": "Udbud",
                "available_filters": {
                    "amount_selection": {
                        "part_name": "Kontraktværdi",
                        "part_id": 137,
                        "allows_multiple": False
                    },
                    "generic_value": {
                        "parts": [
                            {
                                "part_name": "Type",
                                "part_id": 140,
                                "values": ["Bygge og anlæg", "IT og telekommunikation", ...]
                            }
                        ]
                    },
                    "municipality": {
                        "part_name": "Kommune",
                        "allows_multiple": True
                    }
                }
            }
        """
        try:
            # Get module ID
            module_id = self._get_module_id(module_title)
            
            if not module_id:
                return {}
            
            # Get module details with parts
            details = await self.client.get_module_details(module_id)
            if not details.success:
                return {}
            
            parts = details.data.get("parts", [])
            
            # Organize by part type
            result = {
                "module_id": module_id,
                "module_title": module_title,
                "available_filters": {}
            }
            
            for part in parts:
                part_type = part.get("part")
                part_name = part.get("name")
                part_id = part.get("id")
                
                if part_type == "generic_value":
                    # Fetch actual values
                    values_response = await self.client.get_generic_values(part_id)
                    if values_response.success:
                        items = values_response.data
                        if isinstance(items, dict):
                            items = items.get("items", [])
                        
                        value_names = [item.get("name") for item in items if item.get("name")]
                        
                        if "generic_value" not in result["available_filters"]:
                            result["available_filters"]["generic_value"] = {"parts": []}
                        
                        result["available_filters"]["generic_value"]["parts"].append({
                            "part_name": part_name,
                            "part_id": part_id,
                            "values": value_names
                        })
                
                elif part_type == "web_source":
                    # Fetch web sources
                    sources_response = await self.client.get_web_sources(module_id)
                    if sources_response.success:
                        result["available_filters"]["web_source"] = {
                            "part_name": part_name,
                            "part_id": part_id,
                            "requires_selection": True
                        }
                
                else:
                    # Standard filters (municipality, industry, company, etc.)
                    result["available_filters"][part_type] = {
                        "part_name": part_name,
                        "part_id": part_id,
                        "allows_multiple": part.get("canSelectMultiple", True)
                    }
            
            return result
            
        except Exception as e:
            logger.error(f"Error getting filter metadata for {module_title}: {e}")
            return {}
    
    async def build_filter_constraint_section(self, module_titles: List[str]) -> str:
        """
        Byg prompt-sektion med præcise filter-constraints for moduler.
        
        Returns formatted string med ALLE tilgængelige filtre og værdier.
        """
        sections = []
        
        for module_title in module_titles[:5]:  # Max 5 modules
            metadata = await self.get_module_filter_metadata(module_title)
            if not metadata:
                continue
            
            lines = [f"\n**{module_title} - PRÆCISE FILTER-REGLER:**"]
            
            filters = metadata.get("available_filters", {})
            
            # Standard filters
            if "municipality" in filters:
                lines.append(f"✅ Tilladt: 'geografi' (kommuner)")
            
            if "industry" in filters:
                lines.append(f"✅ Tilladt: 'branchekode' (branchekoder)")
            
            if "company" in filters:
                lines.append(f"✅ Tilladt: 'virksomhed' (CVR-numre)")
            
            if "amount_selection" in filters:
                part_name = filters["amount_selection"]["part_name"]
                lines.append(f"✅ Tilladt: 'beløbsgrænse' ({part_name})")
            
            # Generic values
            if "generic_value" in filters:
                for part in filters["generic_value"]["parts"]:
                    part_name = part["part_name"]
                    values = part["values"][:15]  # Top 15
                    values_str = ", ".join(values)
                    lines.append(
                        f"✅ Tilladt: '{part_name.lower()}' → Vælg fra: {values_str}"
                    )
            
            # Web source
            if "web_source" in filters:
                lines.append(f"⚠️ PÅKRÆVET: 'source_selection' (manuel kildevalg)")
            
            # Forbidden filters
            lines.append(f"\n❌ FORBUDT for {module_title}:")
            forbidden = []
            if "amount_selection" not in filters:
                forbidden.append("beløbsgrænse")
            if "generic_value" not in filters:
                forbidden.append("generiske kategorier")
            
            if forbidden:
                lines.append(f"   - {', '.join(forbidden)}")
            
            sections.append("\n".join(lines))
        
        return "\n\n".join(sections)

# Global filter catalog instance
_filter_catalog: Optional[FilterCatalog] = None

def get_filter_catalog() -> FilterCatalog:
    """Få global filter catalog instance."""
    global _filter_catalog
    if _filter_catalog is None:
        _filter_catalog = FilterCatalog()
    return _filter_catalog
